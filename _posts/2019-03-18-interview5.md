## 九、操作系统

### (一)什么是操作系统？

(1)操作系统是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，其他任何软件都必须在操作系统的支持下才能运行。

(2)它的作用有:①作为用户与计算机硬件系统之间的接口:提供命令、程序与图标窗口;

​                       ②作为计算机系统资源的管理者:管理CPU、输入输出设备和文件;

​                       ③实现了对计算机资源的抽象:在“裸机”之上附加一层层的软件作为虚拟机;

(3)它的特征有:①并发:可以允许多个事件在同一个时间间隔内发生;

​                       ②共享:系统中的资源可以供内存中的多个并发执行的进程一起使用;

​                       ③虚拟:可以把一个物理上的实体变成许多个逻辑上的对应物;

​                       ④异步:在多道程序的环境下,程序的执行顺序是不确定的,结果也不确定;



### (二)操作系统的管理功能？

处理机管理、存储器管理、设备管理和文件管理；

 

### (三)操作系统的发展？

（1）人工操作方式：用户用机器语言使用计算机；

（2）脱机输入/输出：由外围机完成输入/输出设备与磁盘间的联动，读纸带不占CPU时间；

（3）单道批处理系统：先把一批作业脱机输入磁带，再让系统在监督程序的监督下一个一个地顺序、连续处理，不过在这个过程中，内存中始终只有一道作业（无法交互）；

（4）多道批处理系统：并发处理，在一个作业暂停的时候处理下一个作业，减少了空闲的时间，但实际上一次还是只运行一个作业（无法交互）；

（5）分时系统：为每个作业配备一个时间片，轮转运行，轮到谁就运行谁（注重交互性）；

（6）实时系统：系统可以及时响应外部事件的请求，在规定时间内完成对这个事件的处理；

 

### (四)管态和目态？

（1）管态，也叫核心态，程序在操作系统内核执行，可以访问计算机里的任何资源；

（2）目态，也叫用户态，程序在操作系统外壳执行，不能直接使用系统资源，也不能改变CPU的工作状态，而且也只能访问这个用户程序自己的存储空间；

 

### (五)为什么要区分管态和目态？

保护操作系统程序；

 

### (六)怎么从目态切换到管态？

（1）系统调用（主动）：处于用户态的进程主动要求切换到内核态的时候使用系统调用方法；

（2）异常（被动）：CPU执行某个用户态的进程发现异常的时候，就会切换到处理可以处理这个异常的内核相关程序中；

（3）I/O设备的中断（被动）：如果I/O设备完成了用户请求操作，就会让CPU暂停执行下一个作业，继续执行刚刚没完成的作业，如果没完成的作业是管态的话，就会切换到管态；

 

### (七)什么是进程？什么是线程？两者的区别？

（1）进程是程序执行时候的一个实例，是系统中可以拥有资源的基本单位，也是独立调度的基本单位，各个进程都有自己的资源、独立的地址空间，独立性比较高，除了全局变量以外的其他资源都不允许别的进程直接访问，除非是专门进行进程间的通信；

（2）线程是轻量级的进程，一个进程可以有很多个线程，属于同一个进程的线程都可以共享进程的资源和地址空间，但他们自己是没有独立的地址空间的，而且也只有一点点必不可少的、用来保证运行的资源，同一个进程的各个线程之间可以相互影响、相互合作；

（3）我的理解是，原来：进程是可以拥有资源的基本单位，也是可以独立调度的基本单位；引入线程的概念以后，可以拥有资源的基本单位还是进程，但独立调度的基本单位成了线程；

（4）这两者之间的根本区别就在于，线程没有用户空间，进程有。

 

### (八)进程的基本状态？

（1）创建：申请空白的PCB，向PCB里填入信息，分配进程运行所需要的资源，从外存转入内存；

（2）就绪：进程已经分配到除了CPU以外所有的资源，只要再得到CPU就可以直接执行；

（3）执行：进程已经获得CPU，正在执行；

（4）阻塞：正在执行的某个程序因为发生了某种事件(I/O请求、申请缓冲区失败等)而暂时没办法继续执行，失去了CPU，进入等待队列；

（5）终止：进程执行结束之后，由操作系统负责把PCB清零，然后把PCB的空间还给系统；

 

### (九)处理机调度的层次？

（1）高级调度：又叫作业调度，可以把外存上处在后备队列里的作业调入内存，为他们创建进程，分配除CPU以外的其他资源，插入就绪队列，这是个单向过程，只能从外存到内存；

（2）中级调度：又叫内存调度，可以把暂时不能运行的进程挂起到外存状态，并把已经具备条件的进程激活回内存，这是“活动就绪-静止就绪”的双向过程；这样可以提高内存利用率和系统吞吐量；

（3）低级调度：又叫进程调度，为内存中就绪队列上的进程分配CPU，使其进入执行状态；

 

### (十)作业/高级调度算法？

（1）先来先服务：不论作业所需要执行时间的长短，严格按照进入就绪队列的先后次序来进行调度；

（2）短作业优先：对同样已经到达就绪队列的作业，先调度需要的时间最短的；

（3）静态优先级调度算法：每次都从后备队列里选择优先级最高的作业装入内存；

（4）高响应比优先调度算法：为每个作业都引入“动态”优先级，这个优先级会随着等待时间的增大而增大，随着需要被服务的时间的增大而减小；

 

### (十一)进程/低级调度算法？

 （1）轮转调度：根据先来先服务原则，为所有就绪的进程排序，并为他们设置时间片；

（2）优先级调度算法：把CPU分配给就绪队列里优先级最高的进程；

（3）多队列调度算法：把进程就绪队列按照类型等性质划分成几个不同的队列，按不同的调度算法来调度；

（4）多级反馈队列调度算法：设置多个就绪队列，队列序号越大，优先级越低，但时间片越大；每个队列内部都是按先来先服务原则排序，新进程进来以后，先放在第一列的队尾等着，CPU按照队列的优先级调度；

（5）基于公平原则的调度算法：有保证调度算法与公平分享调度算法两种；

 

### (十二)死锁的概念？产生原因？必要条件？解决方法？

（1）死锁是多个进程一起陷入没有休止的相互等待状态，这时候他们都是处于阻塞状态的；

（2）死锁产生的原因是：进程之间相互竞争不可抢占的资源；或者进程的推进顺序不当；

（3）死锁产生的条件有：

①互斥：进程对资源进行排他性使用；

​     ②请求和保持：比如说，进程已经获得资源A，申请不到B，就一直占着A等B；

​     ③不可抢占：比如说，进程已经获得A，A就不能被其他进程抢走，只能等A自己释放；

​     ④循环等待；

（4）解决方法：

①静态预防：破坏死锁产生的必要条件之一，对资源进行有序分配；

​    a.破坏请求与保持条件：

​     a1.进程在运行之前，必须一次性申请到他需要的所有资源，不然就不能占用任何资源；

​     a2.进程在获得初期运行所需要的资源以后就开始运行，然后逐步释放、申请其他资源；

   b.破坏不可抢占条件：这个的实现比较复杂，开销很大，一般不用；

   c.破坏循环等待条件：对所有的资源类型进行线性排序，并赋予它们不同的序号，每个进程都必须按照序号递增的顺序请求资源，如果需要多个同类的资源单元的话，就必须一起请求，而如果向申请序号低的资源，就必须放弃比他序号更高的、相同的所有资源；

  ②动态避免：允许系统动态地申请资源，但会在真正地分配资源之前，先进行“试探性”的假分配，看看系统会不会因此而进入不安全状态，如果有可能，就不予分配，让他等待；

  ③动态检测：需要画出相应的资源分配图，如果资源分配图没有办法被完全简化，就是说，如果不能把所有的进程都转化成孤立的结点的话，就认为是发生了死锁；

  ④动态解除：

   a.要么立即通知操作员，人工解除；

   b.要么自动运行死锁解除算法：

​    b1.把死锁进程所需要的所有资源都从其他进程那里夺过来给他；

​    b2.直接终止死锁进程；