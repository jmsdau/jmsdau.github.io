1.一维数组创建

(1)直接输入法:a1=[1,2,3];

(2)步长生成法:a2=[2:3:21];     %从2开始,每3个数字取一次值,作为数组成员,取值最大不能超过21;

(3)定数线性采样法:a3=linspace(1,5,10);      %1和10分别是数组的第一个和最后一个元素,5是采样个数;

(4)定数对数采样法:a3=logspace(1,5,10);     %1和10分别是数组的第一个和最后一个元素,5是采样个数;

2.高维数组创建

(1)直接输入法:b1=[1,2,3;4,5,6;7,8,9;10,11,12];     %同一行的元素用","分隔,换行时用";";

(2)使用下标创建数组:

```matlab
for i=1:2
for j=1:2
for k=1:2
b2(i,j,k)=i+j+k;     %b2中第i行j列k页位置的元素值为i+j+k
end
end
end
```

查看高维数组时可以按页查看,如b2(:,:,1)即为查看第1页所有行列的元素，b2(:,:,2)即为查看第2页所有行列的元素,b2(:,1,:)即为查看每一页中第一列的所有元素,并把输出的结果按页显示;

(3)使用低维数组创建高维数组:

```matlab
b3(:,:,1)=b1;
b3(:,:,2)=2*b1;
b3(:,:,3)=3*b1;
%即,把b1、2*b1、3*b1分别作为新的高维数组b3第一、二、三页的数组
```

(4)使用创建函数创建高维数组:

```matlab
b41=cat(3,b1,2*b1,3*b1);     %把b1复制3次,第一页为b1,第二页为2*b1,第三页为3*b1
b42=repmat(b1,2,3);          %把b1数组本身作为元素复制2行3列,作为b42
b43=reshape(b1,2,6);         
%把b1内的所有元素重新排列成2行6列形式,注意,新行数*列数必须=原数组的元素总数.另外,新结果是把原数组按列读取后的结果,即先读取第一列的两个元素1和4作为新的第一列,再读后面的7和10作为新的第二列,再读后面的2和5作为新的第三列...
```

3.标准数组创建

```matlab
c11=zeros(2,3);       %生成一个2*3的零矩阵
c12=zeros(2);         %生成一个2*2的零矩阵
c13=zeros(2,3,4);     %生成一个2*3*4(2行3列4页)的零矩阵
c14=zeros(size(b1));  %生成一个格式与b1完全相同的零矩阵

%ones用法与zeros完全相同,只不过生成的是全1矩阵;

%eyes用法与zeros完全相同,只不过生成的是单位矩阵;

c41=magic(3);
c42=magic(4);
%magic用于产生一个n*n的魔方矩阵(n>=3),它的每行、列及对角线上的数的和相等,和为((1+2+3+...+n的平方)/n)

%randn用法与zeros完全相同,只不过生成的是随机矩阵,而且不加分号时表示新产生并输出一个随机矩阵,每次的值不同,加分号后就把这次新生成的矩阵值赋给c5了,c5的值就确定了.
```

4.矩阵变换

(1)创建向量用V=[1 1 1];创建矩阵用Data=[1,2,3,4;5,6,7,8;9,10,11,12];

(2)diag:用于构造一个不在对角线上元素全为0的对角矩阵,或以向量形式返回一个矩阵上的对角线元素;

​    ①d11=diag(V,k);以向量V的元素作为矩阵d11的第k条对角线元素,k为0时V为主对角线,>0表示上方第k条,<0表示下方第k条,其余元素均为0.注意此处新生成的d11一定是方阵,且一定刚好装下V中的所有元素;

​    ②d12=diag(V);与diag(V,0)等价;

​    ③d13=diag(Data,k);取矩阵Data的第k条对角线作为向量d12输出,Data不一定非要是方阵.

​    ④d14=diag(Data);与diag(Data,k)等价;

(3)其他:

```matlab
d21=b1.';        %对矩阵b1进行转置,从4*3变为3*4；
d22=b1';         %对矩阵b1进行共轭转置,从4*3变为3*4；
d3=fliplr(b1);   %将b1左右翻转;
d4=flipud(b1);   %将b1上下翻转;
d5=rot90(b1);    %将b1逆时针旋转90度;
d6=tril(b1);     %返回b1的下三角矩阵,其余元素补0;
d7=triu(b1);     %返回b1的上三角矩阵,其余元素补0;
```

5.字符串数组

```matlab
e1='This is an example.'      %要创建字符串数组,直接将字符串直接放入单引号对中赋给变量即可;
e2=deblank(e1);               %删除字符串e1尾部的空格;
e3=strtrim(e1);               %删除字符串开头、结尾处的空格、制表符和回车符;
e4=strrep(e1,'This','That');  %把字符串e1中的'This'替换成'That';strrep不会改变字符串的长度,如果即将替换进去的字符串比即将被替换的字符串长,就会直接覆盖掉原字符串中的内容;

e51=strread('0.41 8.24 3.57');
%用空格分隔字符串中的数字们,把这些数字当成一位数组的变量按序存入数组e51;

[e521 e522 e523] = strread('0.41 8.24 3.57');
%用空格分隔字符串中的数字们,把这些数字按序赋值给e521、e522、e523,用这个方法时前面的e52n数量必须与后面相等;
%strread可以用来从字符串中格式化地读取数据,但现在已经不推荐使用了;

e61=strtok(e1);               
%把字符串e1用空格/换行符/制表符分隔开,只分割一次,返回分割后的前半部分,这里是This;

[e621,e622]=strtok(e1,'a');
%把字符串e1用字符'a'分隔开,把分隔后的前半部分存入e621,把除了e621之外的剩余部分(包括'a'本身及其后面的所有内容)存入e622;
[e621,e622]=strtok(e1,'an');
%strtok的第二个参数分割字符可以是字符串'an',此时,字符串中的每个字符都将看作单独的分隔符,也就是说,无论遇到的是单独的a还是n,都要进行分隔,可以利用循环来实现多次分隔;

str={'hi hello how';'good nice best'}
[token,remain]=strtok(str)
%strtok的输入字符串本身也可以是个元胞数组,这种情况下进行分隔,会对元组中的多个成员进行独立分隔,并将相应的结果组合成新数组,返回数组值;
```

6.架构数组(各操作更类似于数据库的增删改查)

(1)直接创建法:

```matlab
f1.name='tiger';      %可以直接通过数组名.域名=值的方式往结构数组中添加一组成员
f1.age='24';          %在同一组里添加m个成员,就会把它变成1*m的结构数组
f1.number='12345';

f1(2).name='lee';     %可以直接通过数组名(n).域名=值的方式往结构数组中添加n组成员,将其变成n*m的结构数组
f1(2).age='32';
f1(2).number='59871';
%如果结构数组是1*m数组,通过f1命令即可查看数组中每个成员的成员名和具体值,但如果是n*m数组,就只会返回结构信息,没有具体值;
```

(2)命令创建法: 

```matlab
f2(1)=sturct('域名1',values1,'域名2',values2,'域名3',values3);
f2(2)=sturct('域名1',values1,'域名2',values2,'域名3',values3);
%value值本身也可以是多维数组,但要注意,不同成员中的同一个value值的维数必须相同;

%如果所有的value中没有细胞数组,生成的总结构数组的维数就是1*1,如果有细胞数组,而且各个细胞数组的维数必须相同,最终结构数组的维数也一定会与细胞数组相同,如:
f21=struct('type',{'big','little'},'color',{'blue','red'},'x',{3,4});
%此时就会自动生成两个成员,第一个成员f21(1)的type为big,color为blue,x值为3;第二个成员f21(2)的type为little,color为red,x值为4;
```

(3)结构数组的操作

```matlab
f3=fieldnames(f1);                   %用于获取f1中的所有域的域名,即得到的结果为name、age、number

f4=getfield(f1(1),'age');           %用于获取f1中第一个成员的age域的取值;

f1(1)=setfield(f1(1),'name','cat');  %把f1中第一个成员的name值改成cat
```

7.基本运算符号

| **运算符号** | **功能**       | 示例                                                         |
| ------------ | -------------- | ------------------------------------------------------------ |
| ＋           | 矩阵加         | C=A+B,矩阵加法法则                                           |
| -            | 减             | C=A-B,矩阵减法法则                                           |
| *            | 乘             | C=A*B,矩阵乘法法则                                           |
| .*           | 数组乘         | C=A.*B,数组中对应位置的元素两两相乘                          |
| ^            | 矩阵乘方       | C=A^B,A和B必须一个是矩阵,一个是标量(而非数字),如果B是[2],结果即为A * A,B为[3]则为A * A *A |
| .^           | 数组乘方       | C=A^B,A和B必须一个是向量,一个是标量(而非数字),如果B是[2],结果即为A * A,B为[3]则为A * A *A |
| \            | 矩阵左除       | C=A\B=A的逆*B                                                |
| /            | 矩阵右除       | C=A/B=A*B的逆                                                |
| .\           | 数组左除       | C=A.\B,即对应元素左除,C(i,j)=B(i,j)/A(i,j),B中对应元素除以A中对应元素 |
| ./           | 数组右除       | C=A./B,即对应元素右除,C(i,j)=A(i,j)/B(i,j),A中对应元素除以B中对应元素 |
| kron         | 克罗内克张量积 | C=kron(A,B)矩阵A中的每个元素都乘以矩阵B,最终形成一个更大的矩阵 |
| &            | 逻辑与         | C=A&B,如果AB均为标量,则结果为1(真)或0(假);                   |
| \|           | 逻辑或         | C=A\|B,如果一个标量一个数组,就会将标量与数组中的各个元素逐一进行逻辑运算; |
| xor          | 逻辑异或       | C=xor(A,B),如果均为数组,那必须保证两数组行列数对应相同,再由AB对应位置的元素进行逻辑运算 |
| ~            | 逻辑非         | C=~A                                                         |

8.矩阵分析

(1)范数:

​     ①h11=norm(b1,1),将矩阵沿列的方向取绝对值求和，然后选出数值最大的那个值作为1-范数值,这也叫矩阵的1-范数;

​     ②h12=norm(b1,inf),与①类似,不过是沿行方向求和,也叫矩阵的∞-范数;

​     ③h13=norm(b1,2)=norm(b1),求(矩阵b1的转置*矩阵b1本身)这一矩阵的特征值中最大值的平方根,也叫矩阵的2-范数;

(2)条件数:=(矩阵A的范数)*(矩阵A的逆矩阵的范数)

​     ①h21=cond(b1,1) 计算b1的1-范数下的条件数;

​     ②h22=cond(b1,inf) 计算b1的∞-范数下的条件数;

​     ③h23=cond(b1,2)=cond(b1) 计算b1的2-范数下的条件数,如果b1是矩阵,只能用2-范数而不能用1或∞范数;

(3)行列式:h3=det(A),用于求一个方阵A的行列式值;

(4)秩:h4=rank(b1),用于求矩阵b1的秩;

(5)特征值分解(被分解的矩阵必须是方阵):

​     ①E=eig(A),求矩阵A的全部特征值λ,由这些特征值λ构成向量E;

​     ②[V,D]=eig(A),求矩阵A的全部特征值λ,由这些特征值λ构成对角阵D,同时由A的各个特征向量共同构成矩阵V,使AV=VD;

​     ③[V,D]=eig(A,'nobalance'),与②类似,但②中是先对A作相似变换后再求矩阵A的特征值和特征向量,而此处是直接求矩阵A的特征值和特征向量;

​     ④E=eig(A,B),返回n*n阶方阵A和B的N个广义特征值,由这些特征值构成向量E;

​     ⑤[V,D]=eig(A,B),返回方阵A和B的N个广义特征值,构成N×N阶对角阵D,其对角线上的N个元素即为相应的广义特征值,同时将返回相应的特征向量构成N×N阶满秩矩阵,且满足AV=BVD;

(6)化零矩阵:h6=null(b1),即为满足方程组b1*X=0的解空间,可以用来求齐次线性方程的解;

(7)Cholesky分解矩阵:

​     ①h7=chol(X),如果矩阵X是对称正定的,则Cholesky分解将矩阵X分解成一个下三角矩阵和上三角矩阵的乘积.设上三角矩阵为R,则下三角矩阵为其转置,即X=(R')*(R),若X为非对称正定,则输出一个出错信息;

​     ②[R,p]=chol(X),不输出出错信息,如果X是对称正定的,则p=0,R与上述格式得到的结果相同;否则,p为一个正整数.如果X为满秩矩阵,则R为一个阶数为q=p-1的上三角阵,且满足R'*R=X(1:q,1:q);实现Cholesky分解后,线性方程组Ax=b变成R‘Rx=b,所以x=R\(R’\b);

(8)LU分解:

​     ①[L,U] = lu(A) ,将矩阵A分解为一个(心理学上的)下三角矩阵L和一个上三角矩阵U的乘积,使得A=L * U;

​     ②[L,U,P]=lu(A),返回三个矩阵,下三角矩阵L、上三角矩阵U和置换矩阵P,使得P * A=L * U;

​     ③[L,U,P]=lu(A,'vector'),使用向量而不是矩阵的方式返回置换信息,p是一个行向量,满足A(p,:)=L * U;

(9)正交分解:[q,r]=qr(A),将矩阵A分解成一个正交矩阵(矩阵及其转置矩阵的乘积是单位矩阵)q和一个上三角矩阵r的乘积;

(10)奇异值分解 (被分解的矩阵不一定是方阵,可以是任何普通矩阵):[<https://www.cnblogs.com/donaldlee2008/p/5237100.html>]

​     ①s=svd(X),返回矩阵X的奇异值向量;

​     ②[U,S,V]=svd(X),返回一个与X同大小的对角矩阵S,两个酉矩阵U和V,且满足X= U * S * V';

​       a.U:若A为m * n阵,则U为m*m阵,U里面的向量称为左奇异向量,它们是相互正交的;

​       b.S:S是一个m*n的矩阵(除对角线外的其他元素都是0,对角线上的元素为X的奇异值,这些元素按照数值大小降序排列;

​       c.V':V’(V的转置)是一个n*n的矩阵,里面的向量也是正交的,V里面的向量称为右奇异向量;

​       d.求值(注意顺序必须严格一一对应):

​          d1.求((X')*(X))这个方阵的各个特征值λi,并求出相应的特征向量vi,由特征向量组成矩阵V,再求V的转置V'即可;

​          d2.对d1中的每个特征值λi开根号,得到对应的奇异值σi,以σi作为对角线上的元素,降序形成矩阵S;

​          d3.ui=(X*vi)/σi,由ui组成矩阵U;

​     ③[U,S,V] = svd (X,0),得到一个“有效大小”的分解,只计算出矩阵U的前n列,矩阵S的大小为n×n;

9.数值计算实验

(1)差分diff:

​     ①i11=diff(X),如果X是一维数组,就逐个求各个元素之间的差值x1-x0、x2-x1、x3-x2等等,以一维数组形式返回;

​     ②i12=diff(X)=diff(X,1,1),求同一列内上下邻行元素之差x21-x11、x31-x21等等,以数组形式返回,行数比原来-1,列数不变;

​     ③i13=diff(X,1,2),求同一行内前后邻列元素之差x12-x11、x13-x12等等,以数组形式返回,列数比原来-1,行数不变;

​     ④i14=diff(X,n,dim),是沿dim指定的维计算的第n个差分dim为1时为行,2时为列,3时为页;n为2时表示2阶差分,即在1阶差分的基础上再进行一次,两次使用相同的dim值;

(2)梯度gradient:[Fx,Fy]=gradient(F),其中Fx为其水平方向上的梯度,Fy为其垂直方向上的梯度,Fx的第一列元素为原矩阵第二列与第一列元素之差,Fx的第二列元素为原矩阵第三列与第一列元素之差除以2,以此类推:Fx(i,j)=(F(i,j+1)-F(i,j-1))/2,最后一列则为最后两列之差,同理可以得到Fy;

(3)多项式求根roots:r=roots(p),其中,p是一个含有n+1个元素的一维向量,roots会自动将其变成方程((p1 * x的n次方)+(p2 * x的n-1次方)+...+(pn * x)+(pn-1))=0,并对这个方程求解,以列向量的形式返回所有的x解值;

(4)零点

​     ①fzero:

```matlab 
fun=@(x)(x^2+2*x+1);      
y=fzero(fun,-1)
%f表示方程,@(x)表示求未知数x,后面括号中是算式;
%fzero就是用来求fun(x)=0时,x的解值的,x0用来表示初值,如果x0是一个数,就表示解值需要在x0之后,如果是一个一维数组[x1,x2],就表示解值需要在x1和x2之间;
```

​     ②X=fsolve(fun,x0,option),采用最小二乘法来求解非线性方程组,fun是用于定义需求解的非线性方程组的m函数文件名,x0是求根过程的初值,option为最优化工具箱的选项设定,可以省略;如果fun是一个二元函数,x0自然就要变成[x0,y0];

(5)极值

​     ①x=fminbnd(fun,x1,x2),返回一个值x,x是fun中描述的标量值函数在区间x1<x<x2中的局部最小值;

​     ②x=fminsearch(fun,x0),返回一个值x,x是fun中描述的标量值函数在区间x0<x中的局部最小值;

​     ③x=fminunc(fun,x0),从点x0开始,试图找到fun中描述的函数的局部最小值x,点X0可以是标量、向量或矩阵;

(6)积分quadl.

10.符号计算实验

```matlab
syms x                                  
a=simplify(sqrt((sin(x))^2+(cos(x))^2))
%先用syms声明一个未知数x,再用simplify(q)来化简算式q即可
%pretty(f)      将符号表达式化简成与高等数学课本上显示符号表达式形式类似 
%collect(f)     合并符号表达式的同类项 
%horner(f)      将一般的符号表达式转换成嵌套形式的符号表达式 
%factor(f)      对符号表达式进行因式分解 
%expand(f)      对符号表达式进行展开 
%simplify(f)    对符号表达式进行化简,它利用各种类型的代数恒等式,包括求和、积分、三角函数、指数函数以及 Bessel函数等来化简符号表达式 
%simple(f)      对符号表达式尝试多种不同的算法进行化简,以显示长度最短的符号表达式简化形式 
%[r,how]=simple(f)   返回的r为符号表达式进行化简后的形式,how为所采用的简化方法

syms x
y=solve((x+2)^x==2)
%先用syms声明一个未知数x,再用solve(q)来化简等式q即可,注意等式要用==
```