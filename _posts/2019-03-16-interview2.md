## 八、操作系统

### 1.什么是操作系统？

(1)操作系统是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，其他任何软件都必须在操作系统的支持下才能运行。
(2)它的作用有:①作为用户与计算机硬件系统之间的接口:提供命令、程序与图标窗口;
             ②作为计算机系统资源的管理者:管理CPU、输入输出设备和文件;
             ③实现了对计算机资源的抽象:在“裸机”之上附加一层层的软件作为虚拟机;
(3)它的特征有:①并发:可以允许多个事件在同一个时间间隔内发生;
             ②共享:系统中的资源可以供内存中的多个并发执行的进程一起使用;
             ③虚拟:可以把一个物理上的实体变成许多个逻辑上的对应物;
             ④异步:在多道程序的环境下,程序的执行顺序是不确定的,结果也不确定;



### 2.操作系统的发展：

（1）人工操作方式：用户用机器语言使用计算机；
（2）脱机输入/输出：由外围机完成输入/输出设备与磁盘间的联动，读纸带不占CPU时间；
（3）单道批处理系统：先把一批作业脱机输入磁带，再让系统在监督程序的监督下一个一个地顺序、连续处理，不过在这个过程中，内存中始终只有一道作业（无法交互）；
（4）多道批处理系统：并发处理，在一个作业暂停的时候处理下一个作业，减少了空闲的时间，但实际上一次还是只运行一个作业（无法交互）；
（5）分时系统：为每个作业配备一个时间片，轮转运行，轮到谁就运行谁（注重交互性）；
分时系统的相应时间是指用户从终端发出一个命令到系统处理完这个命令并做出回答所需要的时间。这个时间受时间片长度、终端用户个数、命令本身功能、硬件特性、主存与辅存的交换速度等影响。
（6）实时系统：系统可以及时响应外部事件的请求，在规定时间内完成对这个事件的处理；



### 3.管态和目态：

（1）管态，也叫核心态，程序在操作系统内核执行，可以访问计算机里的任何资源；
（2）目态，也叫用户态，程序在操作系统外壳执行，不能直接使用系统资源，也不能改变CPU的工作状态，而且也只能访问这个用户程序自己的存储空间；



### 4.怎么从目态切换到管态？

（1）系统调用（主动）：处于用户态的进程主动要求切换到内核态的时候使用系统调用方法；
（2）异常（被动）：CPU执行某个用户态的进程发现异常的时候，就会切换到处理可以处理这个异常的内核相关程序中；
（3）I/O设备的中断（被动）：如果I/O设备完成了用户请求操作，就会让CPU暂停执行下一个作业，继续执行刚刚没完成的作业，如果没完成的作业是管态的话，就会切换到管态；



### 5.几种中断方式？

（1）由CPU外部引起的，称作中断，如I/O中断、时钟中断、控制台中断等；
（2）来自CPU的内部事件或程序执行中的事件引起的过程，称作异常，比如由于CPU本身
的故障、程序故障等问题引起的中断；
（3）由于在程序中使用了请求系统服务的系统调用而引发的过程，称作"陷入"。前两类通常都称作中断，它们的产生往往是无意、被动的，而陷入是有意和主动的。



### 6.中断与异常?

（1）中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得 CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。
（2）异常是指进程在运行时发生了某种异常事件，使程序无法继续运行。（ 越界错，非法指令、除数 0、越权访问）



### 7.什么是进程？什么是线程？两者的区别？

（1）进程是程序执行时候的一个实例，是系统中可以拥有资源的基本单位，也是独立调度的基本单位，各个进程都有自己的资源、独立的地址空间，独立性比较高，除了全局变量以外的其他资源都不允许别的进程直接访问，除非是专门进行进程间的通信；
（2）线程是轻量级的进程，一个进程可以有很多个线程，属于同一个进程的线程都可以共享进程的资源和地址空间，但他们自己是没有独立的地址空间的，而且也只有一点点必不可少的、用来保证运行的资源，同一个进程的各个线程之间可以相互影响、相互合作；
（3）我的理解是，原来：进程是可以拥有资源的基本单位，也是可以独立调度的基本单位；引入线程的概念以后，可以拥有资源的基本单位还是进程，但独立调度的基本单位成了线程；
（4）这两者之间的根本区别就在于，线程没有用户空间，进程有。



### 8.进程的三态？

就绪、执行、阻塞



### 9.进程的五态？

（1）创建：申请空白的PCB，向PCB里填入信息，分配进程运行所需要的资源，从外存转入内存；
（2）就绪：进程已经分配到除了CPU以外所有的资源，只要再得到CPU就可以直接执行；
（3）执行：进程已经获得CPU，正在执行；
（4）阻塞：正在执行的某个程序因为发生了某种事件(I/O请求、申请缓冲区失败等)而暂时没办法继续执行，失去了CPU，进入等待队列；
（5）终止：进程执行结束之后，由操作系统负责把PCB清零，然后把PCB的空间还给系统；



### 10.进程的七态？

创建、就绪、执行、阻塞、终止、挂起、激活；

### 

### 11.PCB的内容？

PCB就是进程控制块，系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志。进程与PCB是一一对应的。包含如下信息：
（1）进程标识符：也就是名字；
（2）进程当前的状态；
（3）进程的程序和数据地址；
（4）进程拥有的资源清单；
（5）进程的优先级；
（6）CPU的现场保护区：当进程因为某种原因而不能继续占用CPU的时候，必须释放CPU，这时候就要把CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。
（7）进程的同步与通信机制；
（8）进程所在队列的PCB的链接字；
（9）其他信息；



### 12.线程同步的几种方式？

（1）临界区：当有多个线程访问同一个独占性的共享资源的时候，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。
（2）事件：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。
（3）互斥量：和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。
（4）信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。它保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。



### 13.处理机调度的层次：

（1）高级调度：又叫作业调度，可以把外存上处在后备队列里的作业调入内存，为他们创建进程，分配除CPU以外的其他资源，插入就绪队列，这是个单向过程，只能从外存到内存；
（2）中级调度：又叫内存调度，可以把暂时不能运行的进程挂起到外存状态，并把已经具备条件的进程激活回内存，这是“活动就绪-静止就绪”的双向过程；这样可以提高内存利用率和系统吞吐量；
（3）低级调度：又叫进程调度，为内存中就绪队列上的进程分配CPU，使其进入执行状态；



### 14.作业/高级调度算法？

（1）先来先服务：不论作业所需要执行时间的长短，严格按照进入就绪队列的先后次序来进行调度；
（2）短作业优先：对同样已经到达就绪队列的作业，先调度需要的时间最短的；
（3）静态优先级调度算法：每次都从后备队列里选择优先级最高的作业装入内存；
（4）高响应比优先调度算法：为每个作业都引入“动态”优先级，这个优先级会随着等待时间的增大而增大，随着需要被服务的时间的增大而减小；



### 15.进程/低级调度算法？

（1）轮转调度：根据先来先服务原则，为所有就绪的进程排序，并为他们设置时间片；
（2）优先级调度算法：把CPU分配给就绪队列里优先级最高的进程；
（3）多队列调度算法：把进程就绪队列按照类型等性质划分成几个不同的队列，按不同的调度算法来调度；
（4）多级反馈队列调度算法：设置多个就绪队列，队列序号越大，优先级越低，但时间片越大；每个队列内部都是按先来先服务原则排序，新进程进来以后，先放在第一列的队尾等着，CPU按照队列的优先级调度；
（5）基于公平原则的调度算法：有保证调度算法与公平分享调度算法两种；



### 16.死锁的概念？产生原因？必要条件？解决方法？

（1）死锁是多个进程一起陷入没有休止的相互等待状态，这时候他们都是处于阻塞状态的；
（2）死锁产生的原因是：进程之间相互竞争不可抢占的资源；或者进程的推进顺序不当；
（3）死锁产生的条件有：
①互斥：进程对资源进行排他性使用；
     ②请求和保持：比如说，进程已经获得资源A，申请不到B，就一直占着A等B；
     ③不可抢占：比如说，进程已经获得A，A就不能被其他进程抢走，只能等A自己释放；
     ④循环等待；
（4）解决方法：
①静态预防：破坏死锁产生的必要条件之一，对资源进行有序分配；
    a.破坏请求与保持条件：
     a1.进程在运行之前，必须一次性申请到他需要的所有资源，不然就不能占用任何资源；
     a2.进程在获得初期运行所需要的资源以后就开始运行，然后逐步释放、申请其他资源；
b.破坏不可抢占条件：这个的实现比较复杂，开销很大，一般不用；
c.破坏循环等待条件：对所有的资源类型进行线性排序，并赋予它们不同的序号，每个进程都必须按照序号递增的顺序请求资源，如果需要多个同类的资源单元的话，就必须一起请求，而如果向申请序号低的资源，就必须放弃比他序号更高的、相同的所有资源；
  ②动态避免：比如银行家算法，允许系统动态地申请资源，但会在真正地分配资源之前，先进行“试探性”的假分配，看看系统会不会因此而进入不安全状态，如果有可能，就不予分配，让他等待；安全状态是指至少有一个资源分配序列不会导致死锁。
  ③动态检测：需要画出相应的资源分配图，如果资源分配图没有办法被完全简化，就是说，如果不能把所有的进程都转化成孤立的结点的话，就认为是发生了死锁；
  ④动态解除：
a.要么立即通知操作员，人工解除；
b.要么自动运行死锁解除算法：
 b1.把死锁进程所需要的所有资源都从其他进程那里夺过来给他；
 b2.直接终止死锁进程；



### 17.死锁与“饥饿”之间的主要差别？

（1）死锁：多个并发进程相互等待对方占用的资源而产生的错误现象。
（2）饥饿：由于系统采用的资源分配算法不当，虽然每个资源占有者都在有限时间内释放它所占的资源，但仍然使一些进程永远得不到资源的一种错误现象。



### 18.连续分配分区存储管理方式？

为一个用户程序分配一个连续的内存空间，也就是说，程序中代码或者数据的逻辑地址相邻；
（1）单一连续分配：同一时间内，整个内存的用户空间都由一个程序独占；
（2）固定分区分配：把内存固定地分成一些大小相等/不相等的分区，每一个进程都占用一个分区，而操作系统占用的也是一个分区，这个一般采用顺序分配算法；
（3）动态分区分配：在装入程序的时候按照它的初始要求分配内存空间，并且在他执行的过程中通过系统调用来进行分配，或者改变分区的大小；有适用于小型系统的顺序式搜索和适用于大中型系统的索引搜索；
 ①顺序-首次适应算法：空闲的分区以首地址递增的顺序互相链接，分配的时候从前往后找，分配第一个符合条件的分区；
  a.优点：优先利用内存低地址部分的内存空间，保留高地址部分的空闲分区，方便以后用；
  b.缺点：低地址部分会被不断划分，产生大量的小碎片；
          每次查找都从低地址部分开始，查找开销大；
 ②顺序-循环首次适应算法：仍然按照地址递增的顺序排列，但不是每次都从首部开始查找，而是从上一次找到的空闲分区的下一个分区开始向后找；
  a.优点：使内存空闲分区分配均匀，减少了查找开销；
  b.缺点：会缺乏比较“大”的空闲分区；
 ③顺序-最佳适应算法：将空闲区按照大小递增的顺序进行排列，分配的时候从小往大找；
  a.优点：主存利用率高；
  b.缺点：会产生很多难以再次利用的小碎片；
 ④顺序-最坏适应算法：将空闲区按照大小递减的顺序排列；
  a.优点：剩下的难以利用的小碎片比较少，对中小型作业比较有利；查找最快；
  b.缺点：存储区里没有“大”的分区，大的程序可能装不下；
 ⑤索引-快速适应算法：把所有的空闲分区按大小分成多个链表，同一个表内的分区大小相同，同时在内存中设置一个管理索引表，记录每个表内分区的大小和他们的指针；
  a.优点：查找效率高，可以保留较大的分区，不会产生外碎片；
  b.缺点：算法复杂，开销较大；
⑥索引-伙伴系统：所有分区都按2的n次方的大小为标准分配，其他与快速适应算法一样；
（4）动态可重定位分区分配：相当于动态分区分配算法+紧凑功能；



### 19.分段和分页?

其实都是一种对地址的划分或者映射的方式。



### 20.分页存储管理方式？

（1）把进程的逻辑地址空间分成若干个大小相等的片，称为页，并且为每个页都编上号，都从0开始，同时，把整个内存空间也按同样的大小分成若干个块，大小跟页一样，也为每块内存都编上号；
（2）在为进程分配内存的时候，把各个连续的页都分配到不连续的实际内存当中，用页表来存放每个页对应的物理块的编号，方便以后查找；
（3）这个是两次访存的：先去内存中找页表，得到物理块号，再根据物理块号去内存中存取数据；



### 21.分段存储管理方式？

分页的时候，数据和代码没有差别，仅仅按照位置和大小来进行分割，由系统自动完成分割工作，但不够人性化；
分段存储可以把“数据”单独分成一段，“代码”单独分成一段然后再进行各自的二次分割；



### 22.分页与分段？

（1）共同点：采用离散分配方式，通过地址映射机构实现地址变换；
（2）不同点：
①页式存储提供连续的逻辑地址，页的大小是确定的，作业地址空间是一维的；
 ②段式存储中，“段间”的逻辑地址不连续，段的大小不确定，作业地址空间是二维的；



### 23.页面置换算法？（缺页率FIFO最高，OPT最低）

（1）OPT-最佳值换算法：优先选择在“未来”最长一段时间内不会被访问的页面，很难做；
（2）FIFO-先进先出算法：优先选择已经进来最久的物理块淘汰（把已经调入的页面按先后顺序排好即可）；Belady现象：在某些情况下，反而有分配给进程的物理块越多，缺页率越高的情况；
（3）LRU-最近最久未使用算法：优先选择把“最近”最长一段时间内未被使用的页面淘汰；
（4）LFU-最少使用置换算法：优先选择到当前时间为止被访问次数最少的页面来置换；
（5）clock置换算法：为每个页面都设置一个访问位，再把内存中所有的页面都通过链接指针变成一个循环队列，某个页被访问时，访问位就变成1，只有在需要淘汰一个页面时，才改变访问位；



### 24.抖动？

抖动也就是颠簸，是指在页面置换过程中，刚刚调出的页面马上又要调入内存，刚刚调入的页面马上又要调出，发生的频繁的页面调度行为；



### 25.常用文件分配方式？ 

文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种:连续分配、链接分配和索引分配。
(1)连续分配，要求每个文件在磁盘上占有一组连续的块。 
(2)链接分配，采取离散分配的方式，分为隐式链接分配和显式链接分配。
(3)索引分配，把每个文件的所有的盘块号集中在起构成索引块(表)。



### 26.常用的磁盘调度算法？

(1)先来先服务算法(FCFS),根据进程请求访问磁盘的先后顺序进行调度。
(2)最短寻找时间优先算法(SSTF),选择处理的磁道是与当前磁头所在磁道距离最近的磁道，使每次的寻找时间最短。会产生“饥饿”现象。
(3)扫描算法(SCAN),也叫电梯算法，在磁头当前移动方向上选择与当前磁头所在距离最近的请求作为下一次服务的对象。实际上是在SSTF算法的基础上规定了磁头运动的方向。
(4)循环扫描算法(CSCAN),在SCAN算法的基础上规定磁头单向移动来提供服务，到达磁盘端点回返时直接快速返回起始端。



### 27.引入缓冲区的目的是什么？

(1)缓和CPU与I/0设备间速度不匹配的矛盾。
(2)减少对CPU的中断频率，放宽对CPU中断响应时间的限制。
(3)解决基本数据单元大小(即数据粒度)不匹配的问题。
(4)提高CPU和I/0设备之间的并行性。



### 28.什么是缓冲区溢出？缓冲区溢出的原因与危害？

（1）缓冲区溢出是指，在计算机向缓冲区内填充数据位数的时候,如果位数超过了缓冲区本身的容量,溢出的数据就会覆盖在合法数据上。比如，绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配,这就为缓冲区溢出埋下隐患.
（2）危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出。而缓冲区溢出中，最危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回的时候改变返回程序的地址，让它跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码。



### 29.外存分配的几种方式，及各种优劣？

（1）连续分配：在创建文件的时候，分配一组连续的块；FAT（文件分配表）中每个文件只要一项，说明起始块和文件长度。对于顺序文件有利。磁盘寻道次数和寻道时间最少，但有外部碎片问题。
（2）链式分配：一个文件的信息存放在若干个不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块。fat 中每个文件同样只需要一项，包括文件名、起始块号和最后块号。任何一个自由块都可以加入到链中。不存在外部碎片问题，但需要更多的寻道次数和寻道时间。
（3）索引分配：每个文件在 FAT 中有一个一级索引，索引包含分配给文件的每个分区的入口。文件的索引保存在单独的一个块中，FAT 中该文件的入口指向这一块。是普遍采用的一种方式，但也需要较多的寻道次数和寻道空间
（4）多重索引：首先，多重索引也是索引分配的一种，只不过它是将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中。