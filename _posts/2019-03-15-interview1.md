## 一、本科专业

### (一)什么是物联网？

（1）物联网是一个借助互联网、传统电信网这些信息载体，让所有现实世界中相对独立这些的普通物体也能实现互联互通的功能的网络。

（2）一方面呢，随着人们生活水平的提高，有越来越多的东西，比如家具、仪器、办公设备，需要联网，让人们实现远程数据分析、或者操控物体的行为；另一方面，互联网也不可能永远只能借助计算机、手机这些专门的终端设备来实现，我们需要扩大信息世界，就是这两方面的需求，催生了物联网这样的新型网络。

（3）最开始的物联网，就只是能够把普通的物品通过射频识别之类的信息传感设备与互联网连接起来，实现智能化的识别与管理而已，随着这几年的发展，物联网能够实现的功能越来越多，可以把我们身边随处可见的一些物品贴上RFID标签或者其他的信息传感设备，与手机或者电脑相连，通过各种通讯网络实时采集物体的各种信息，与传统的互联网结合，形成更大的一个网络。



###  (二)物联网与传统计算机专业的关系？

物联网工程是要以计算机科学与技术为基础的。



### (三)51与arm体系有什么不同？

它们基本都遵循原始的计算机体系结构，不同的是，arm的ROM和RAM远大于51，而且IO功能和处理速度也是两个级别的，arm能上很多操作系统，51只能勉强上极其简单的实时操作系统，所以arm常用来开发手机等多媒体产品，51只能完成有限的实时控制功能。



### (四) 冯·诺依曼结构？

（1）概念：是一种把程序指令序列和数据存放在同一个存储器的不同地址的结构。也就是说，程序本身也可以被看作是一种特殊的“数据”，可以被处理和存储，也可以和普通的数据存放在同一个存储器里面，采用单一的地址总线和数据总线。

（2）特点：

第一，程序和数据被存放在同一个存储器的不同地址上；

第二，各个存储单元是按线性规律排列的；

第三，严格按照程序/数据—>内存—>取指令执行指令的顺序来执行程序。执行之前，要把需要的程序和数据先放进存储器（也就是内存）里，然后在执行的时候，把要执行的程序和需要处理的数据按照顺序从存储器中取出来，一条条执行。

第四，组成上有运算器，存储器，控制器，输入/输出设备：

（3）优点：它可以最大限度地利用资源，因为数据和程序放在同一个地方，不用花销太多的资源就能取到数据和程序。

（4）缺点：程序和数据存放在同一个存储区里，存取程序和数据的时候需要共享同一条总线，会影响数据处理速度。



## 二、程序设计语言

### (一)C语言和C++的区别？

（1）首先，C++是来源于c语言的。

（2）C语言最初设计的目的是为了编写操作系统，所以它的规则比较简单，也可以直接对内存进行操作，程序运行效率很高。

（3）但是c语言在处理大问题、复杂问题的时候所表现出来的弱点也很明显，比方说，它没有数据类型的检查机制，代码的重用性也比较差，所以就有了c++这个升级版。

（4）比方说，c++中所有变量和函数都必须要有数据类型，而在c语言里面，我们可以不给一个函数定义返回参数的类型，函数的参数也可以没有数据类型，但是在c++里面，所有的程序元素都必须指明数据类型

（5）还有就是，C++在c语言的基础上增加了面向对象程序设计的支持，比方说，有了“类”这个概念，就有了比较良好的灵活性、继承性和前瞻性。



### (二) 为什么 c 语言里数组存储先行后列，为什么不先列后行？

我认为按行还是按列存储，应该没有太大的区别吧，最终只是为了形成一个统一的规则，所以选择了一种优先存储规则。

 

### (三) c 语言里为什么用 printf 作为输出，printf 输出含有几个参数？

（1）因为c语言本身并不提供输入输出语句，输入输出操作都是由c标准函数库中的函数来实现的，printf和scanf就是这样的函数，其实除了printf还有putchar、puts之类的其他输出函数，只不过我们最常用的还是这一个而已。

（2）printf含有两个参数，一个是格式控制参数，一个是输出表列。格式控制是用双引号括起来的字符串，也叫格式字符串，包括格式声明和普通字符，格式声明就是由%和格式字符组成的，普通字符就是在输出的时候按照原样直接输出的字符。输出表列的话，就是程序需要输出的一些数据，可以是常量、变量或者表达式。



### (四)C++的三大特性是什么？

（1）封装：类就是支持数据封装的工具，对象则是数据封装的实现，在封装中，还提供一种对数据访问的控制机制，比如类的成员可以就有公有成员，私有成员，保护成员这三种类型，对不同类型的访问方式也不一样。

（2）继承：一个类可以根据需要生成它的派生类，派生类还可以再生成派生类。派生类既可以继承基类的成员，也可以定义自己的成员，这样的话代码的重用性就会比较高。

（3）多态：多态性是指对不同的类的对象发出相同的消息将会有不同的实现。

 

### (五) 介绍一下什么是多态，函数重载的判断？

 C++支持多态性表现在：

（1）C++允许函数重载和运算符重载。其中，函数重载就是指以同一个名字来命名多个函数实现版本，判断方法有：参数的个数、参数的类型和顺序，还有常函数const，就是，如果同时在一个类里，对于函数名相同的const函数和非const函数就能够构成重载，有const只读，没有const就读写都可以。再有就是，不能把返回值作为函数重载的条件，原因是编译器在编译时不会去判断函数的返回类型，函数只有调用后，编译器才会去验证返回类型，所以返回值不能作为函数重载的依据。

（2）C++语言通过定义虚函数来支持动态联编，动态联编是多态性的一个重要的特征。如果在基类的函数前面加上virtual关键字，这个函数就叫做虚函数。如果在派生类里面重写这个函数，在函数运行的时候，就会根据对象的实际类型来调用相应的函数。

 

### (六)c++里面的抽象类的定义，作用？

抽象类可以用来表示现实世界中的抽象概念，是一种只能定义类型，但是不能产生对象的类。它只能够被继承并且重写相关的函数。在c++里面，是通过纯虚函数来实现抽象类的，纯虚函数就是指，只定义了原型的成员函数，在c++里面，一个具有纯虚函数的基类就是抽象类，抽象类只能够作为父类来被继承，而不能够创建对象，继承他的子类也必须实现纯虚函数的具体功能。接口就是一种特殊的抽象类。

 

### (七)Java与c++?

（1）对于C和C++来说，它们是由编译程序来把源程序直接全部翻译成二进制代码，形成一个目标程序，可以由操作系统来直接执行，所以它们是编译型语言。

（2）而Java不一样，它首先由编译器编译成.class（字节码）文件，然后在通过Java虚拟机从.class文件中读一行解释执行一行，所以它是先编译后解释的语言。

（3）个人认为，c++的功能比较全，但是java的使用更灵活。

 

### (八)面向对象程序设计的优点？

（1）程序可读性比较高，而且由于继承的存在，即使用户的需求变了，我们的也只需要维护局部模块就可以，这样的话维护就比较方便。

（2）程序的可重用性比较高。

（3）在进行程序设计的时候，效率比较高。因为我们可以对现实世界中的事物进行抽象，从而产生类。这更接近于日常生活和自然的思考方式。

（4）程序更容易扩展。

 

### (九) 介绍 jsp

JSP的全名是Java Server Pages，是一种动态网页技术标准，它是通过在传统的静态网页HTML文件里面插入Java程序段和JSP标记，从而形成JSP文件的。当客户端请求jsp文件的时候，web服务器就会执行这个jsp文件，然后以HTML的格式返回给客户，也就是说，jsp程序的执行是由web服务器来完成的。

 

## 三、数据结构

### (一)数据结构的概念

数据结构是指相互之间存在一种或多种特定关系的数据元素的集合，数据结构包括3方面的内容：逻辑结构、存储结构和对数据的运算。

（1）逻辑结构就是指对数据之间的关系的描述，这个与数据的存储结构无关，同一种逻辑结构可以有多种存储结构，数据的逻辑结构主要有四大类：集合、线性结构、图状结构和网状结构。

（2）存储结构就是物理结构，是数据的逻辑结构在计算机中的表示，包括数据元素的表示和关系的表示，主要包括顺序存储、链式存储、索引存储和散列存储。

（3）对数据的运算：包括运算的定义和实现，定义是针对逻辑结构的，可以指出运算的功能，而实现是针对存储结构的，可以指出运算的具体操作步骤。

 

### (二)数据结构的排序算法？

（1）插入排序：每次都把一个待排序的记录，按照关键字的大小插入到前面已经排好序的子序列里，直到全部排完为止。

（2）希尔排序：先把整个记录序列分割成若干个子序列，分别进行直接插入排序，等到整个序列中的记录基本有序之后，再对全体进行一次直接插入排序。

（3）冒泡排序:：对于有n个元素的数组，从前往后或者从后往前两两相比，每次都把较大的放在后面，这样一趟比较结束后，最大的元素就被移动到了数组最后面，n-1趟以后，数组就可以按从大到小的顺序排列了。

（4）快速排序：通过一趟排序把所有的记录分割成独立的两个部分，其中一部分里面的所有记录的关键字都比另一部分小，然后再分别对两个部分再进行快速排序，一直到整个序列有序为止。

（5）选择排序：每一趟都在未排序的所有记录里选择最小的那个记录，作为有序序列部分的下一个记录。

（6）归并排序：把两个或者两个以上的有序表组合成个一新的有序表。二路归并排序的核心操作就是把一维数组里面前后相邻的两个有序序列归并成一个有序序列。

（7）基数排序：采用多关键字的排序思想，借助“分配/收集”两种操作对逻辑关键字进行排序。

（8）堆排序：一种树形选择排序方法。在排序过程中把L[1... N]堪称一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲和孩子之间的关系，在当前的无序区选择里面最大或最小的元素。



### (三) 二分法的前提，二分法的时间复杂度？

线性表以顺序方式存储，并且按照关键码值排好序。

时间复杂度是log2n。



### (四)什么是哈希表？

散列表(也叫哈希表)，是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中的一个位置来访问记录，从而加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做哈希表。

 

### (五)什么是二叉树，二叉树的作用是什么？

（1）树：是一种包含n个结点的有穷集合，集合中的每一个元素都称为一个结点，其中有一个特殊的结点称为根节点，根结点之外的结点元素被分为m个互不相交的集合，其中每个集合本身也是一棵树，成为根节点的子树。

（2）二叉树：是另一种树形结构，每个结点最多有两颗子树，而且二叉树的子树有左右之分，次序不能随便颠倒，二叉树的第i层上的结点数目最多是2的i-1次方。

（3）二叉树的作用：二叉树与数组、向量、链表都是顺序容器，都提供了按位置来访问数据的手段。但是数组、向量和链表都都是按照位置来确定数据的，如果想要通过值来获取数据的话，只能通过遍历的方式。而二叉树在很大程度上解决了这个问题，二叉树是按照值来保存、访问元素的。



## 四、计算机组成原理

### (一)二进制文件和 ASCII 码文件的区别？

（1）ASCII文件也称为文本文件，这种文件在磁盘中存放的时候，每个字符都对应一个字节，用来存放对应的ASCII码。ASCII码文件可以在屏幕上按字符显示，我们也可以读懂文件的内容。

（2）而二进制文件是按二进制的编码方式来存放文件的。虽然也可以在屏幕上显示，但我们读不懂它的内容，而系统在处理这些文件的时候，并不区分类型，都看成是字符流，按字节进行处理。



### (二) 二进制的补码怎么求，八位的数的补码最大值和最小值分别是多少？

（1）正数的补码：与原码相同。

（2）负数的补码：第一位符号位是1，其余的位是这个数的[绝对值](http://www.so.com/s?q=%E7%BB%9D%E5%AF%B9%E5%80%BC&ie=utf-8&src=internal_wenda_recommend_textn)的原码按位取反，然后再把整个数加1。

（3）8位二进制补码表示整数的最小值是 -128, 最大值是 +127.
 因为正数的补码就是它本身，8位二进制最大的正整数是 0111111，也就是十进制值 127。而负数的补码是它原数的反码加1，最小值，就是负得最多的数，也就是二进制 1000 0000。十进制-128。



## 五、软件工程

### (一)学软件工程的收获

（1）我刚上大一的时候以为，做“软件”就是进行程序设计而已，直到学了软件工程以后才知道，软件工程是采用工程的原理和技术来开发、维护软件的过程，不单单需要软件开发技术，还需要管理技术，还需要提前考虑好软件在运行、维护过程中可能出现的各种问题，尽可能设计出一个实用、好用的软件。

（2）这就需要大量的准备工作，比方说，要搞清楚用户对于一个软件真正的需求是什么，他到底想要完成什么样的功能，这个过程就需要我们不断深入地与用户进行协商，然后拟定一个最终的评判标准。

（3）还要对整个软件进行设计，然后才能真正进行软件开发，开发完成以后还要进行大量的测试，测试通过以后才能够进行交付，而且软件交付也不是最终的过程，我们还要一直负责软件的维护、再工程等等一系列后续服务，是一个很复杂的流程，绝不仅仅是进行程序设计那么简单。

 

### (二)白盒测试里的各种覆盖？

(1)语句覆盖：使被测程序的每个“可执行语句”至少执行一次。

(2)判定覆盖：使每个“判定”的所有可能“结果”至少出现一次（真 假）。

(3)条件覆盖：使每个判定中的每个“条件”的所有可能“结果”至少出现一次（真假 真假）。

(4)判定/条件覆盖：使得每个“判定”的所有可能“结果”至少出现一次，同时，使得每个判定中的每个“条件”的所有可能“结果”至少出现一次（真假 假真 假假）。

(5)条件组合覆盖：使每个判定中的条件结果的所有“组合”都至少出现一次（真真 真假 假真 假假）。

(6)路径覆盖：每条可能执行到的“路径”都至少经过一次。

 

### (三)alpha测试和beta测试？

（1）alpha测试是用户在开发环境下的测试，或者是在开发内部的用户在模拟实际环境下的测试，在测试的时候出现的问题，可以立刻反馈给开发人员，由他们来进行分析和处理。

（2）beta测试是由软件的多个用户在不同的实际环境下进行的测试，开发者是不在测试现场的，在测试的时候出现的问题，由用户记录下来，并且定期向开发者报告，由他们分析、处理，只有在通过了beta测试阶段以后，软件才能真正交付给所有的用户使用。

 

### (四)生命周期模型？

（1）瀑布模型：把一个开发过程分成收集需求、分析、设计、编码、测试、维护六个部分，只有完成前面一步的任务之后才能开始下一步的内容，上一步的输出文档就是这一步的输入文档，每一步的任务完成以后，都要交出合格的文档，每一步都会有反馈，如果反馈有错误的话，就退回前一步，解决问题。缺点是用户很难一次给出所有的需求，瀑布模型没法适应用户需求的反复变化。

（2）V模型：通过开发和测试同时进行的方式来缩短开发周期，提高开发效率，大体可以分为需求分析、概要设计、详细设计、软件编码、单元测试、集成测试、系统测试和验收测试八个过程。

（3）增量模型：把软件分成许多个构件，每个构件都分别当成是一个软件来进行分析、设计、编码、测试，开发人员一次一个构件地提交给用户，最后组装到一起，优点是可以将核心功能提供给用户，再慢慢增加功能，让用户逐步适应，缺点是这些构件最后可能不能集成到一起。

（4）螺旋模型：强调风险分析，就是在快速原型模型的每一个原型前面都引入一个非常严格的风险分析，每一个原型都经过制定计划、风险分析、实施工程、客户评估四步走，每一个模型都会标识一个或者多个主要风险，直到所有的主要风险因素都被确定为止，优点是设计比较灵活，缺点是使用这种模型需要相当丰富的风险评估经验。

（5）喷泉模型：以用户的需求为动力，用来描述面向对象的软件开发过程，这个模型认为软件开发过程中自下而上的周期的各阶段是相互迭代的，开发人员可以同步开发-易语言。

 

### (五)CMM成熟度级别?

（1）初始级：软件过程是无序的，甚至是混乱的，没有什么是经过定义的，项目成功的完成完全依赖个人的努力和核心人物的作用。

（2）可重复级：建立基本的项目管理过程和实践去跟踪项目成本、进度、质量，必要的过程准则可以重复类似项目的成功。

（3）已定义级：软件已经文档化、标准化、并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护。

（4）已管理级：制定了软件过程和产品质量的详细度量标准。软件质量都被开发组织人员所理解和控制。

（5）优化级：加强了定量分析，通过质量反馈和新技术的反馈过程不断持续的改进。

 

### (六)测试和调试的区别？

（1）软件测试：只需要发现错误就可以，但是是软件测试人员和程序员都参与的一项工作，是贯穿整个生命周期的。

（2）软件调试：需要发现错误、定位错误、更改错误、继续测试，是程序员自己参与的过程，主要是在软件开发阶段进行。

 

## 六、数据库

### (一)模式与视图

(1)模式:数据的结构信息(抽象);

(2)视图:数据本身(具体);

 

### (二)三级模式

(1)E-外模式/子模式/用户模式:对某一个用户所能够看到、处理的数据的结构描述,这些数据只是全局数据中的一小部分;

(2)C-模式/概念模式/全局模式/逻辑模式:对可以从全局角度理解、管理的数据的结构描述,含有相应的关联约束,体现的是数据之间的本质联系;

(3)I-内部模式/物理模式/存储模式:被存储在物理介质上的数据,含有数据的存储路径、存储方式和索引方式等内容;

 

### (三)两层映像

(1)外模式-模式(E-C):把数据的概念视图转换成外部视图,便于用户观察、使用;

(2)模式-内模式(C-I):把数据的概念视图转换成内部视图,便于计算机存储、处理;

 

### (四)数据的独立性(尽量避免修改应用程序)

(1)逻辑数据独立性:不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序;

(2)物理数据独立性:即使内部模式、存储方式发生了变化,也不需要改变模式,只需要改变C-I映像即可,不需要改变外部模式,以免改变应用程序;

 

### (五)数据模型

(1)数据模型:规定了模式的统一描述方式的模型,包括数据结构、对数据的操作和操作时要受到的约束;数据模型是对“模式”的结构的抽象,模式则是对“数据”的结构的抽象;

(2)经典数据模型:①关系模型:表;

​                           ②层次模型:树;

​                           ③网状模型:图;

 

### (六)数据库系统的发展

(1)第一代:基于网状模型或层次模型的数据库系统;

(2)第二代:基于关系模型的数据库系统:消除了由用户建立指针的弊端、将逐一记录的操作改进为支持记录集合的操作、即非过程化的操作;

(3)第三代:面向对象数据库系统:允许复杂的数据类型存在、突破了关系模型第一范式的限制、既支持记录集合的操作,又支持面向对象的操作;

 

### (七)关系模型三要素

(1)关系数据结构:也就是表;

(2)关系操作:数据表与数据表间可能发生的各种操作,包括并、差、乘积、选择、投影;

(3)完整性约束:以上操作所应该遵循的约束条件;

  ①实体完整性:关系的主码中的属性值不能为空值(不知道或没有意义的值),是体现“实体能够区分并唯一标识元组”的规则;

  ②参照完整性:如果关系A中的外码就是关系B中的主码,那么外码的值要么与相应的主码值完全一致,要么为空,决不能乱取值;

  ③用户自定义的完整性:具体情况具体分析;

 

### (八)元组、域、笛卡尔积

元组:具有相同数据类型的行;

域:具有相同数据类型的列,列中元素的个数叫做域的基数;

笛卡尔积:两个域X x Y,如X={A,B},Y={a,b},则X x Y={(A,a),(A,b),(B,a),(B,b)};

​               笛卡尔积中的每个元素叫做一个n元组,n是集合的数量,以上例子就是2元组;

​               一个元组中的每个值都叫做分量,如A就是一个分量;

​               笛卡尔积的基数是组成它的所有域的基数之积,如以上例子就是2*2=4;

关系:是一个由行与列组成的、能够表达数据及数据之间联系的二维表;

笛卡尔积的子集,笛卡尔积的所有元素中,符合某种要求的那部分,可以构成新关系; 在一个关系中的列的名字,叫属性名;用R(属性名A1:属性所在的域名a1,属性名B1:属性所在的域名b1)表示,域名可省;

关系的特性:每一个列中的值必须属于同一个数据类型;

​                   不同的列可以来自同一个域,其中的每一个列都是一个属性,有不同的属性名;

​                   关系中的行和列可以互换;

​                   关系≠表:关系中不能有两个完全相同的元组,现实中实际的表中却可以;

​                   满足第一范式:属性不可再分(如,一个列不能再进一步分解成两个列);

 

### (九)候选码、主键、主属性、外码

(1)如果在关系中,有一个属性组(组),其值能够唯一地标识每个元组,一旦去掉这个组中的任何一个属性,它都不能再唯一地标识每个元组,就把这个属性组称为候选码;如果一个关系中,只能由所有属性一起构成候选码,就成这个候选码为全码;

(2)如果在一个关系中,有多个候选码可以选择,则选定其中一个作为关系的主键/主码;

(3)包含在任何一个候选码中的属性都算是主属性,其他属性则是非主属性;

(4)如果关系R中的一个属性组不是R的候选码,但它是另一个关系S候选码中的一部分,则成这个属性组为R的外码或外键;两个关系通常是靠外码连接起来的;即,其它关系的候选键,可以是R中的主属性或非主属性;

 

### (十)关系代数运算

运算符的优先顺序:() - θ – 存在 - 全部 -  ¬ - ∧ - ∨



### (十一)五种基本运算:并、差、选择、投影、乘积

(0)进行并、差、交操作的两个集合,必须满足“并相容性”,

即,两个集合的属性的数目必须相同,且处于同一位置的属性的取值必须来自同一个域;

如R(A1,A2…An),与S(B1,B2…Bm)两个集合必须满足n=m且Domain(A1)=Domain(B1);

(1)并-R∪S:其中元素要么属于R,要么属于S,属于一个即可,无顺序;

​            R∪S={ t | t∈R ∨ t∈S};

(2)差-R-S:其中元素属于R,但不能属于S,只能属于一个,有顺序;

​            R-S={ t | t∈R ∧ t￠S};

(3)积-R(<a1,a2…an>) x S(<b1,b2…bm>):由R中的元组(而非属性)与S中的元组进行所有可能的拼接构成,如果两个集合中的元组的属性完全不同,则积的元组数目是R与S的元组数目之积,度数(属性数)是两者度数之和;就好像学生表x课程表一样,结果是两者的各种可能的组合;无顺序;

(4)选择-σcon(R):从R中选出满足给定条件condition的元组(行)们,con就是条件表达式;

​                σ A3>0 ∨ B1=’x’  (R)= { t | t∈R ∧ con(t)=’真’ };

(5)投影-∏A(R):从R中选择属性包含在A这个集合中的属性(列)们,并按A的顺序重新排列;

​               ∏A1,A2,A3(R)={< t[A1] , t[A2] , t[A3]> | t∈R };

(6)交-R∩S:其中元素必须同时属于R和S;

​            R∩S={ t | t∈R ∧ t∈S};

(7) θ-连接- ![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg):在R与S的笛卡尔积中,选取R中的属性A与S中的属性B这两个属性之间的关系满足θ这个条件的元组构成,θ可以是>,≧,<,≦,=,≠等关系;

①如果θ的值是≠,那么这个连接也叫等值连接;

   ②如果没那行θ,就叫自然连接,由R与S中选取相同属性B上值相同的元组连接构成;

   ③一般可以投影(选择(连接));

(8)除-R÷S:如果S中的所有属性是R中所有属性的真子集(完全属于但不等于),那么R÷S的属性就是在R的属性中去掉所有属于S的属性,元组就是,满足“与S中的‘每个’元组组合形成的新元组都是R中的元组”这个条件的元组;

(9)外连接:在R与S连接时,如果关系R中的元素在S中找不到可以匹配的元组,为了避免该元组信息丢失,可以把该元组与S中假定存在的、值为空值的元组形成连接,得结果;

左外连接是左侧满,右外连接是右侧满,开口向满的一侧;



## 七、前沿技术

### (一)神经网络是什么？

答：人工神经网络是一种通过模仿动物神经网络的行为特征，来进行分布式并行信息处理的一种算法数学模型。这种网络需要依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的，另外，它还具有自学习和自适应的能力。



### (二)你对人工智能有什么了解?强人工智能可能实现吗？

（1）人工智能主要是研究怎么才能让计算机去做过去只有人才能做的智能工作的一种工作，这个过程就不仅仅是涉及到计算机科学了，还包括心理学、哲学、语言学等各种学科的内容，比如说扫地机器人、智能家居之类的产品就在很大的程度上改变了我们的生活方式。

（2）人工智能应该说是大势所趋，现在应该还只是弱人工智能时代，而强人工智能的话指的就是制造出一种，在任何领域里都通用的、都可以具备人的能力的智能机器，至于对于强人工智能会不会实现，我个人认为是有难度的，因为像人的自我意识、思维情感这些东西应该是很难复制或者说程序化的。



### (三)什么是机器学习? 什么是深度学习？

（1）机器学习的话，我认为它是人工智能的核心，主要研究的问题就是怎么样才能让计算机程序随着经验的积累自动的去提高它的性能，这是一门专门用来研究，计算机怎么才能模拟或者实现人类的学习行为，从而获取新的知识或者是技能，重新组织已有的知识结构，并且不断地改善自身的性能的学科，可以说机器学习才是让计算机具有智能的根本途径吧。

（2）比方说，深度学习就是机器学习研究中的一个新的领域，是一种基于神经网络发展起来的机器学习算法。它的主要目标呢，是在于建立、模拟人脑进行分析学习的神经网络，换句话说就是深度学习是研究怎么才能让机器去模拟人脑来分析解释数据，比如图像、 声音文本等这些形式的数据的学科。 

 

### (四)什么是大数据?

大数据是一种规模大到在获取、存储、管理、分析等方面都远远超出了传统数据库软件工具能力范围的数据集合，具有大量、高速、多样、低价值密度以及真实性这五大特性。对于大数据技术来说，我认为它的主要目的不是在于去掌握这些数据信息本身，而是在于对它们进行专业化的处理，从而挖掘其背后的深层含义。

 

### (五)什么是数据挖掘?

数据挖掘并不只是简单的把数据呈现出来就可以，相反，它更多的是要去从大型的数据库里面抽取出有意义的信息或者模式的这么一个过程，这里所说的有意义的信息具体来说指的就是那些非平凡的、隐含的或者说是以前没有被我们注意过、但是具有潜在价值的信息。

 

### (六)大数据和机器学习之间有什么联系?

大数据是相对于传统的数据而言的一个概念，而机器学习指的是计算机通过我们设计的各种学习模式去学习数据，并且通过从数据中学习到的信息反过来对计算机自身进行校正，以便于更好的学习的过程，这其中整个过程都是迭代的。

之所以大数据和机器学习经常会一起出现，是因为我们会用机器学习这个工具去进行大数据的分析工作，也就是说，机器学习可以看作是我们做大数据分析的一个比较好用的工具，当然了，进行大数据分析可以使用的工具并不只有机器学习，机器学习也并不是只能用来做大数据分析的。

 

### (七)什么是云计算?

首先，云，是互联网的一种比喻说法。云计算呢，能够使计算的过程分布在大量的分布式计算机上，而不是本地的计算机或者是远程服务器里，举个例子来说，就好比是从古老的单台发电机模式转向了电厂集中供电的模式，云计算就意味着“计算能力”本身也可以作为一种商品来流通，就好像我们日常生活中的煤气水电一样，取用很方便，费用也低。通过云计算，我们可以把计算的任务转移到服务器端，而对普通的用户端来说，只需要一个显示器就可以。

