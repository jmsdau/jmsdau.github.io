### (三)选择结构

#### 1.if语句:

```
if(条件A){
    动作语句;
}
```

(1)如果条件A是x!=0,那么可以省略!=0号,直接用if(x);

(2)如果条件A是x==0,那么可以省略==0号,直接用if(!x);

#### 2.switch语句:

```
switch(需要求值的表达式B){
    case 值1:
    动作语句1; //case本身默认把两个case之间的内容全部作为上一个case的内容,因此不需要大括号;
    break;
    /*break的作用在于直接结束当前的switch语句,跳出switch,如果将其删去,程序会从第一个匹配的case开始执行语句,直到其下面的所有语句都执行完毕才退出switch,也是因此,最后的default语句不需要break;*/
    
    case 值2:
    动作语句2;
    break;
    
    case 值3:
    动作语句3;
    break;
    ......
    default:
    动作语句4;
}
```

### (四)循环结构

#### 1.while语句:

```
while(条件表达式A){
    动作语句;
}
```

(1)如果条件A是x!=0,那么可以省略!=0号,直接用while(x);

(2)如果条件A是x==0,那么可以省略==0号,直接用while(!x);

2.do...while语句:

```
do{
    动作语句;
}while(条件表达式A);
```

(1)会先执行动作语句一次,再判断条件A是否成立,如果条件成立,则继续执行动作语句,直到某次执行完毕后发现条件A不再成立,才退出循环;

(2)实用性远不如while;

#### 3.for语句:

```
for(循环变量初值表达式A;循环条件表达式B;循环变量改变方法表达式C){
动作语句;
}
```

举例:

```
#include <stdio.h>
int main(){
	for(int i=1,sum=0;i<=10;i++){
		sum=sum+i;
	}
	printf("%d",sum);
	return 0;
}
//c语言中不允许在for语句的表达式里定义变量,即int i=1,但c++可以,如果要使用这种方法,需要把文件保存成.cpp文件
```

#### 4.break语句:不止适用于switch语句,还适用于各种循环,可以用break语句在需要的时候提前退出循环;

```
#include <stdio.h>
int main(){
	int n,sum=0;
	for(int i=1;i<=100;i++){
		sum=sum+i;
		if(sum>=100){
			break;
		}
	}
	printf("sum=%d",sum);
	return 0;
}
//输出结果为105
```

#### 5.continue:可以在需要的地方临时退出"正在进行的循环中的这一次轮回",进入循环中的下一轮;

```
#include <stdio.h>
int main(){
	int sum=0;
	for(int i=1;i<=5;i++){
		if(i%2==1){
			continue;//如果i是奇数,就结束这次轮回,不执行下面的语句,直接进入下一轮
		}
		sum=sum+i;
	}
	printf("sum=%d",sum);
	return 0;
}
//输出1-5之间的所有偶数之和,答案为2+4=6
```

### (五)数组

#### 1.一维数组

(1)格式:数据类型 数组名[数组大小(必须是整数常量,不能是变量)];

​             int a[10];

(2)初始化:

​    ①给出用逗号隔开的从第一个元素开始的若干元素的初值,并用大括号括住l,后面未被赋初值的元素将会由不同的编译器内部实现的不同而被赋以不同的初值(可能是很大的随机数),而一般情况默认初值为0;

​    ②如果想给整个数组都赋初值0,只需要把第一个元素赋为0即可;

​    ③根据一些条件,可以不断让后一位的结果由前一位或前若干位计算得来,这种做法叫做递推,递推可以分为顺推或逆推;

```
#include <stdio.h>
int main(){
	int a[5]={1,2,3};
	int b[5]={0};
	int c[5];
	c[0]=1;//一定要提前定义数组中的至少一个元素
	for(int i=1;i<5;i++){
		c[i]=c[i-1]*2;
	}
    for(int j=0;j<5;j++){
		printf("a[%d]=%d,",j,a[j]);
		printf("b[%d]=%d,",j,b[j]);
		printf("c[%d]=%d,",j,c[j]);
		printf("\n");
	}
	return 0;
}
/*
a[0]=1,b[0]=0,c[0]=1,
a[0]=2,b[0]=0,c[0]=2,
a[0]=3,b[0]=0,c[0]=4,
a[0]=0,b[0]=0,c[0]=8,
a[0]=0,b[0]=0,c[0]=16,
可见,a数组的后面两个元素值为0,b数组的全部元素为0,c数组从1开始成二倍关系增长;
*/
```

2.冒泡排序:

(1)原理:对于有n个元素的数组,从前至后两两相比,较大的放在后面,一趟比较结束后,最大的元素就被移动到了数组最后面,n-1趟以后,数组就可以按从大到小的顺序排列了;

```
#include <stdio.h>
int main(){
	int a[10]={3,1,4,5,2};
	for(int i=1;i<5;i++){   //保证以下语句执行n-1=5-1=4轮
		for(int j=0;j<5-i;j++){   //在第i轮中,把a[i]与a[i+1]比较,大的放在后面
			if(a[j]>a[j+1]){
			int temp=a[j];
			a[j]=a[j+1];
			a[j+1]=temp;
			}
		}
	}
    for(int n=0;n<5;n++){
		printf("%d,",a[n]);
	}
	return 0;
}
//输出12345
```

#### 3.二维数组:

(1)格式:数据类型 数组名[第一维大小(行数)] [第二维大小(列数)];

​            int a[5] [6];

(2)访问:数组名[下标1] [下标2];

(3)初始化:先按第一维的顺序依次用大括号给出第二维初始化的情况,然后将它们用逗号分隔,并用大括号全部括住,而在这些被赋初值的元素之外的部分将被默认赋初值为0;

```
/*#include <stdio.h>
int main(){
	int a[3][6]={{3,1,4,5,2},{0},{1,2}};
	for(int i=0;i<4;i++){         //按行输出
		for(int j=0;j<6;j++){    //在第i行中按列输出
			printf("%d",a[i][j]);
		}
		printf("\n");
	}
	return 0;
}*/
/*输出:
314520         定义了31452,但第二维的大小是6,因此计算机自动给第六个元素赋值为0
000000         定义为全0,因此显示全0
120000         定义了12,但第二维的大小是6,因此计算机自动给第三四五六个元素赋值为0
*/
```

(4)其他:如果数组较大(大概1000000级别),就需要将其定义在"主函数main"外面,否则会使程序异常退出,原因书函数内部申请的局部变量来自系统栈,允许申请的空间较小;而函数外部申请的全局变量来自静态存储区,允许申请的空间较大;

